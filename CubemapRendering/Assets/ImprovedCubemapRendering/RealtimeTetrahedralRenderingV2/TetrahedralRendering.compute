//|||||||||||||||||||||||||||||||||||||| INCLUDES ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| INCLUDES ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| INCLUDES ||||||||||||||||||||||||||||||||||||||

#include "CubemapSampling.cginc"
#include "TetrahedralMapping.cginc"
#include "SpecularConvolutionGGX.cginc"

//|||||||||||||||||||||||||||||||||||||| PARAMETERS ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| PARAMETERS ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| PARAMETERS ||||||||||||||||||||||||||||||||||||||

Texture2DArray<float4> TetrahedralCubemapLUT;
RWTexture2D<float4> TetrahedralColorMap;

float2 TetrahedronMapResolution;
float2 TetrahedronFaceResolution;
float2 CubemapOutput2DResolution;

int TetrahedronFaceIndex;

RWTexture2D<float4> TetrahedronFaceRender;
RWTexture2D<float4> TetrahedronFaceMapOutput;
RWTexture2DArray<float4> CubemapOutput;

RWTexture2DArray<float4> CubemapInput;
RWTexture2D<float4> CubemapOutput2D;

//|||||||||||||||||||||||||||||||||||||| TETRAHEDRON FACE COMBINE (NAIVE MAPPING) ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TETRAHEDRON FACE COMBINE (NAIVE MAPPING) ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TETRAHEDRON FACE COMBINE (NAIVE MAPPING) ||||||||||||||||||||||||||||||||||||||

#pragma kernel TetrahedralFaceCombineNaive
[numthreads(4, 4, 1)]
void TetrahedralFaceCombineNaive(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2(0.5f, 0.5f) + uint2(id.xy)) / TetrahedronMapResolution;
    
    switch (TetrahedronFaceIndex)
    {
        case 0: //GREEN TOP LEFT QUAD
            if (uv.x < 0.5f && uv.y > 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f, uv.y * 2.0f - 1.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
        case 1: //YELLOW TOP RIGHT QUAD
            if (uv.x > 0.5f && uv.y > 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f - 1.0f, uv.y * 2.0f - 1.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
        case 2: //BLUE BOTTOM LEFT QUAD
            if (uv.x < 0.5f && uv.y < 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f, uv.y * 2.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
        case 3: //RED TOP RIGHT QUAD
            if (uv.x > 0.5f && uv.y < 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f - 1.0f, uv.y * 2.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
    }
}

//|||||||||||||||||||||||||||||||||||||| TETRAHEDRON FACE COMBINE (COMPACT MAPPING) ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TETRAHEDRON FACE COMBINE (COMPACT MAPPING) ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TETRAHEDRON FACE COMBINE (COMPACT MAPPING) ||||||||||||||||||||||||||||||||||||||
/*
#pragma kernel TetrahedralFaceCombineCompact
[numthreads(4, 4, 1)]
void TetrahedralFaceCombineCompact(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2(0.5f, 0.5f) + uint2(id.xy)) / TetrahedronMapResolution;
    
    switch (TetrahedronFaceIndex)
    {
        case 0: //GREEN BOTTOM TRIANGLE
            if (IsPointInTriangle(uv, float2(0.0f, 0.0f), float2(0.5f, 0.5f), float2(1.0f, 0.0f)))
            {
                float2 localUV = float2(uv.x, uv.y * 2.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
        case 1: //YELLOW TOP TRIANGLE
            if (IsPointInTriangle(uv, float2(0.0f, 1.0f), float2(0.5f, 0.5f), float2(1.0f, 1.0f)))
            {
                float2 localUV = float2(uv.x, (1.0f - uv.y) * 2.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
        //NOTE: FLIP ON Y
        
            break;
        case 2: //BLUE RIGHT TRIANGLE
            if (IsPointInTriangle(uv, float2(1.0f, 1.0f), float2(0.5f, 0.5f), float2(1.0f, 0.0f)))
            {
                float2 localUV = float2(uv.x * 2.0f - 1.0f, uv.y);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
        //NOTE: ROTATE UV CLOCKWISE 90.0f

            break;
        case 3: //RED LEFT TRIANGLE
            if (IsPointInTriangle(uv, float2(0.0f, 1.0f), float2(0.5f, 0.5f), float2(0.0f, 0.0f)))
            {
                float2 localUV = float2(uv.x * 2.0f, uv.y);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
        //NOTE: ROTATE UV CLOCKWISE -90.0f

            break;
    }
}
*/
//|||||||||||||||||||||||||||||||||||||| TETRAHEDRAL MAP TO CUBEMAP ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TETRAHEDRAL MAP TO CUBEMAP ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| TETRAHEDRAL MAP TO CUBEMAP ||||||||||||||||||||||||||||||||||||||

#pragma kernel TetrahedralMapToCubemap
[numthreads(4, 4, 6)]
void TetrahedralMapToCubemap(uint3 id : SV_DispatchThreadID)
{
    float2 tetrahedralUV = TetrahedralCubemapLUT[id.xyz];
    uint2 tetrahedralUVInt = tetrahedralUV * TetrahedronMapResolution;
    
    CubemapOutput[id.xyz] = TetrahedralColorMap[tetrahedralUVInt];
}

//|||||||||||||||||||||||||||||||||||||| CUBEMAP (TEX2DARRAY) TO CUBEMAP (TEX2D) ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| CUBEMAP (TEX2DARRAY) TO CUBEMAP (TEX2D) ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| CUBEMAP (TEX2DARRAY) TO CUBEMAP (TEX2D) ||||||||||||||||||||||||||||||||||||||

#pragma kernel CubemapToTexture2D
[numthreads(4, 4, 1)]
void CubemapToTexture2D(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2(0.5f, 0.5f) + uint2(id.xy)) / CubemapOutput2DResolution;

    //compute a normalized X coordinate (so for each "face" we are on, it's 0..1 relative to each face)
    float xNormalizedFace = (uv.x * 6.0f) % 1.0f;
    int xNormalizedFaceInt = (int) (xNormalizedFace * CubemapOutput2DResolution.y);

    //compute face index (remember we are doing a 6:1 cubemap layout)
    int faceIndex = ((int) (uv.x * 6));

    //reverse the input UV Y coordinate so the faces show up at the proper orentation
    CubemapOutput2D[id.xy] = CubemapInput[uint3(xNormalizedFaceInt, (CubemapOutput2DResolution.y - 1) - id.y, faceIndex)];
}

//|||||||||||||||||||||||||||||||||||||| SPECULAR CONVOLUTION GGX ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| SPECULAR CONVOLUTION GGX ||||||||||||||||||||||||||||||||||||||
//|||||||||||||||||||||||||||||||||||||| SPECULAR CONVOLUTION GGX ||||||||||||||||||||||||||||||||||||||

int CubemapMipFaceResolution;
int SpecularConvolutionSamples;

float SpecularRoughness;

#pragma kernel ConvolveSpecularGGX
[numthreads(4, 4, 6)]
void ConvolveSpecularGGX(uint3 id : SV_DispatchThreadID)
{
    //NOTE TO SELF: The 0.5f offsets here are CRITICAL when computing normalized UVs in a compute shader
    float2 normalizedUV = float2(id.x + 0.5f, id.y + 0.5f) / CubemapMipFaceResolution;
    float2 signedUV = normalizedUV * 2.0f - 1.0f;
    
    float3 rayDirection = CubemapTexelToDirection(signedUV, id.z);
        
    float4 result = float4(0, 0, 0, 0);
    
    for (int i = 0; i < SpecularConvolutionSamples; i++)
    {
        float2 sampleSet = Hammersley(i, SpecularConvolutionSamples);

        float3 specularRayDirection = ImportanceSampleGGX_VNDF(sampleSet, rayDirection, rayDirection, SpecularRoughness);
        
        uint3 textureSampleCoords = RayDirectionToCubemapTexel(specularRayDirection, CubemapMipFaceResolution * 2);
        
        result += CubemapInput[textureSampleCoords];
    }
    
    result /= SpecularConvolutionSamples;
    
    result = max(0.0f, result);
    
    CubemapOutput[id.xyz] = result;
}

















int GaussianSampleRadius;

float GaussianWeight(int x, int y, int radius)
{
    float sigma = radius / 2.0;
    float coeff = 1.0 / (pow(2.0 * 3.14159265359 * sigma * sigma, 1.5));
    float exponent = -(x * x + y * y) / (2.0 * sigma * sigma);
    return coeff * exp(exponent);
}

#pragma kernel ConvolveSpecularGaussian
[numthreads(4, 4, 6)]
void ConvolveSpecularGaussian(uint3 id : SV_DispatchThreadID)
{
    float4 result = float4(0, 0, 0, 0);
    float weightSum = 0.0;
    
    for (int x = -GaussianSampleRadius; x <= GaussianSampleRadius; x++)
    {
        for (int y = -GaussianSampleRadius; y <= GaussianSampleRadius; y++)
        {
            uint2 samplePos = id.xy * 2 + uint2(x, y);
            float weight = GaussianWeight(x, y, GaussianSampleRadius);
            result += CubemapInput[uint3(samplePos, id.z)] * weight;
            weightSum += weight;
        }
    }
    
    result /= weightSum;
    CubemapOutput[id.xyz] = result;
}
