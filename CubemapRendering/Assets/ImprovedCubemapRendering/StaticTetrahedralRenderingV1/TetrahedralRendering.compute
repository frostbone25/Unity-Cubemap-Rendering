Texture2DArray<float4> TetrahedralCubemapLUT;
RWTexture2D<float4> TetrahedralColorMap;

float2 TetrahedronMapResolution;
float2 TetrahedronFaceResolution;
float2 CubemapOutput2DResolution;

int TetrahedronFaceIndex;

RWTexture2D<float4> TetrahedronFaceRender;
RWTexture2D<float4> TetrahedronFaceMapOutput;
RWTexture2DArray<float4> CubemapOutput;

RWTexture2DArray<float4> CubemapInput;
RWTexture2D<float4> CubemapOutput2D;

#pragma kernel TetrahedralFaceCombine
[numthreads(4, 4, 1)]
void TetrahedralFaceCombine(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2(0.5f, 0.5f) + uint2(id.xy)) / TetrahedronMapResolution;
    
    switch (TetrahedronFaceIndex)
    {
        case 0: //GREEN TOP LEFT QUAD
            if (uv.x < 0.5f && uv.y > 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f, uv.y * 2.0f - 1.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
        case 1: //YELLOW TOP RIGHT QUAD
            if (uv.x > 0.5f && uv.y > 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f - 1.0f, uv.y * 2.0f - 1.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
        case 2: //BLUE BOTTOM LEFT QUAD
            if (uv.x < 0.5f && uv.y < 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f, uv.y * 2.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
        case 3: //RED TOP RIGHT QUAD
            if (uv.x > 0.5f && uv.y < 0.5f)
            {
                float2 localUV = float2(uv.x * 2.0f - 1.0f, uv.y * 2.0f);
                uint2 localUVInt = localUV * TetrahedronFaceResolution;
                TetrahedronFaceMapOutput[id.xy] = TetrahedronFaceRender[localUVInt];
            }
        
            break;
    }
}

#pragma kernel TetrahedralMapToCubemap
[numthreads(4, 4, 6)]
void TetrahedralMapToCubemap(uint3 id : SV_DispatchThreadID)
{
    float2 tetrahedralUV = TetrahedralCubemapLUT[id.xyz];
    uint2 tetrahedralUVInt = tetrahedralUV * TetrahedronMapResolution;
    
    CubemapOutput[id.xyz] = TetrahedralColorMap[tetrahedralUVInt];
}

#pragma kernel CubemapToTexture2D
[numthreads(4, 4, 1)]
void CubemapToTexture2D(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (float2(0.5f, 0.5f) + uint2(id.xy)) / CubemapOutput2DResolution;

    //compute a normalized X coordinate (so for each "face" we are on, it's 0..1 relative to each face)
    float xNormalizedFace = (uv.x * 6.0f) % 1.0f;
    int xNormalizedFaceInt = (int) (xNormalizedFace * CubemapOutput2DResolution.y);

    //compute face index (remember we are doing a 6:1 cubemap layout)
    int faceIndex = ((int) (uv.x * 6));

    //reverse the input UV Y coordinate so the faces show up at the proper orentation
    CubemapOutput2D[id.xy] = CubemapInput[uint3(xNormalizedFaceInt, (CubemapOutput2DResolution.y - 1) - id.y, faceIndex)];
}